"""
DOCX formatter for report generation.
"""

from pathlib import Path
from typing import Dict, Any
import re
from datetime import datetime

try:
    from docx import Document
    from docx.shared import Inches, Pt, RGBColor
    from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
    from docx.enum.style import WD_STYLE_TYPE
    from docx.oxml.shared import OxmlElement
    from docx.oxml.ns import qn
    DOCX_AVAILABLE = True
except ImportError:
    DOCX_AVAILABLE = False
    Document = None

from src.formatters.base_formatter import BaseFormatter
from src.utils.diagram_renderer import DiagramRenderer


class DocxFormatter(BaseFormatter):
    """
    Formatter for Microsoft Word DOCX output format.
    
    Generates professional Word documents with:
    - Proper formatting
    - Headings and styles
    - Tables
    - Images (for diagrams)
    """

    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        if not DOCX_AVAILABLE:
            self.logger.warning("python-docx not available. DOCX formatting will be limited.")
        self.diagram_renderer = DiagramRenderer()
    
    def format_report(
        self,
        sections: Dict[str, Any],
        diagrams: Dict[str, Any],
        citations: Dict[str, Any],
        output_path: Path
    ) -> Path:
        """
        Format report as DOCX.
        
        Args:
            sections: Report sections
            diagrams: Generated diagrams
            citations: Citations and references
            output_path: Output file path
            
        Returns:
            Path to generated DOCX file
        """
        if not DOCX_AVAILABLE:
            raise ImportError("python-docx is required for DOCX formatting. Install with: pip install python-docx")
        
        self.logger.info(f"Formatting report as DOCX: {output_path}")
        
        output_path = self._validate_output_path(output_path)
        
        # Create document
        doc = Document()
        
        # Add title page
        self._add_title_page(doc, sections)
        
        # Add table of contents
        if self.config.get("include_table_of_contents", True):
            self._add_table_of_contents(doc)
        
        # Add sections
        self._add_sections(doc, sections)
        
        # Add diagrams
        if diagrams:
            self._add_diagrams_section(doc, diagrams)
        
        # Add references
        if citations.get("references_section"):
            self._add_references(doc, citations)
        
        # Save document
        doc.save(str(output_path))
        
        self.logger.info(f"DOCX report saved to: {output_path}")
        return output_path
    
    def _add_title_page(self, doc: Document, sections: Dict[str, Any]):
        """Add professionally formatted title page to document."""
        title = self.config.get("title", "Technical Report")
        
        # Add spacing from top
        for _ in range(6):
            doc.add_paragraph()
        
        # Title - Large and bold
        title_paragraph = doc.add_paragraph()
        title_run = title_paragraph.add_run(title)
        title_run.font.size = Pt(28)
        title_run.font.bold = True
        title_run.font.color.rgb = RGBColor(0, 51, 102)  # Dark blue
        title_paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        title_paragraph.space_after = Pt(24)
        
        # Subtitle
        subtitle_para = doc.add_paragraph()
        subtitle_run = subtitle_para.add_run("Automated Technical Report")
        subtitle_run.font.size = Pt(16)
        subtitle_run.font.color.rgb = RGBColor(102, 102, 102)  # Gray
        subtitle_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        subtitle_para.space_after = Pt(48)
        
        # Add more spacing
        for _ in range(8):
            doc.add_paragraph()
        
        # Generation info at bottom
        info_para = doc.add_paragraph()
        info_run = info_para.add_run("Generated by Report Generator")
        info_run.font.italic = True
        info_run.font.size = Pt(10)
        info_run.font.color.rgb = RGBColor(128, 128, 128)
        info_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        
        # Date
        date_para = doc.add_paragraph()
        date_run = date_para.add_run(datetime.now().strftime("%B %d, %Y"))
        date_run.font.size = Pt(10)
        date_run.font.color.rgb = RGBColor(128, 128, 128)
        date_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER
        
        # Add page break
        doc.add_page_break()
    
    def _add_table_of_contents(self, doc: Document):
        """Add table of contents."""
        toc_heading = doc.add_heading("Table of Contents", level=1)
        
        # This is a simple TOC - in a real implementation, you'd use Word's built-in TOC
        toc_items = [
            "Abstract",
            "Introduction", 
            "Methodology",
            "Results",
            "Discussion",
            "Conclusion",
            "References"
        ]
        
        for item in toc_items:
            p = doc.add_paragraph(item, style='List Number')
        
        doc.add_page_break()
    
    def _add_sections(self, doc: Document, sections: Dict[str, Any]):
        """Add report sections to document with proper formatting."""
        section_order = ["abstract", "introduction", "methodology", "results", "discussion", "conclusion"]
        
        for section_name in section_order:
            if section_name in sections:
                # Add heading with proper styling
                heading = doc.add_heading(section_name.title(), level=1)
                heading.space_before = Pt(18)
                heading.space_after = Pt(12)
                
                # Add content with markdown parsing
                content = sections[section_name]
                self._add_formatted_content(doc, content)
                
                # Add spacing after section
                spacing_para = doc.add_paragraph()
                spacing_para.space_after = Pt(12)
    
    def _add_diagrams_section(self, doc: Document, diagrams: Dict[str, Any]):
        """Add diagrams section with rendered images."""
        if "metadata" not in diagrams:
            return
        
        heading = doc.add_heading("Diagrams", level=1)
        heading.space_before = Pt(18)
        heading.space_after = Pt(12)
        
        for diagram_name, diagram_content in diagrams.items():
            if diagram_name != "metadata" and diagram_content:
                # Add diagram heading
                subheading = doc.add_heading(diagram_name.replace('_', ' ').title(), level=2)
                subheading.space_before = Pt(12)
                subheading.space_after = Pt(6)
                
                # Try to render Mermaid diagram to image
                if diagram_content.strip():
                    try:
                        image_path = self.diagram_renderer.render_mermaid_to_png(diagram_content)
                        if image_path and image_path.exists():
                            # Add image to document
                            doc.add_picture(str(image_path), width=Inches(6.0))
                            # Clean up temp file
                            image_path.unlink(missing_ok=True)
                        else:
                            # Fallback to code block if rendering fails
                            self._add_code_block(doc, diagram_content)
                    except Exception as e:
                        self.logger.warning(f"Failed to render diagram {diagram_name}: {e}")
                        self._add_code_block(doc, diagram_content)
                
                # Add spacing
                doc.add_paragraph().space_after = Pt(12)
    
    def _add_references(self, doc: Document, citations: Dict[str, Any]):
        """Add references section."""
        heading = doc.add_heading("References", level=1)
        heading.space_before = Pt(18)
        heading.space_after = Pt(12)
        
        references_text = citations.get("references_section", "")
        # Remove markdown formatting
        references_text = references_text.replace("# References", "").strip()
        
        self._add_formatted_content(doc, references_text)
    
    def _add_formatted_content(self, doc: Document, text: str):
        """Add formatted text with proper markdown parsing."""
        # Split content into blocks
        blocks = text.split('\n\n')
        
        for block in blocks:
            if not block.strip():
                continue
            
            # Check for tables
            if '|' in block and block.count('\n') > 0:
                self._add_table(doc, block)
            # Check for code blocks
            elif block.strip().startswith('```'):
                code_content = block.strip().strip('```').strip()
                # Remove language identifier if present
                if '\n' in code_content:
                    parts = code_content.split('\n', 1)
                    if len(parts) > 1 and not ' ' in parts[0]:
                        code_content = parts[1]
                self._add_code_block(doc, code_content)
            # Check for headings (should be rare in content)
            elif block.strip().startswith('#'):
                level = len(block) - len(block.lstrip('#'))
                heading_text = block.lstrip('#').strip()
                doc.add_heading(heading_text, level=min(level + 1, 9))
            # Check for lists
            elif block.strip().startswith(('-', '*', '+')):
                self._add_bullet_list(doc, block)
            elif re.match(r'^\d+\.', block.strip()):
                self._add_numbered_list(doc, block)
            # Regular paragraph
            else:
                self._add_formatted_paragraph(doc, block)
    
    def _add_formatted_paragraph(self, doc: Document, text: str):
        """Add paragraph with inline formatting (bold, italic, code)."""
        para = doc.add_paragraph()
        
        # Parse inline markdown
        parts = re.split(r'(\*\*.*?\*\*|\*.*?\*|`.*?`)', text)
        
        for part in parts:
            if not part:
                continue
            
            if part.startswith('**') and part.endswith('**'):
                # Bold text
                run = para.add_run(part[2:-2])
                run.bold = True
            elif part.startswith('*') and part.endswith('*'):
                # Italic text
                run = para.add_run(part[1:-1])
                run.italic = True
            elif part.startswith('`') and part.endswith('`'):
                # Inline code
                run = para.add_run(part[1:-1])
                run.font.name = 'Courier New'
                run.font.size = Pt(10)
            else:
                # Regular text
                para.add_run(part)
    
    def _add_table(self, doc: Document, markdown_table: str):
        """Parse and add markdown table to document."""
        lines = [line.strip() for line in markdown_table.split('\n') if line.strip()]
        
        if len(lines) < 2:
            return
        
        # Parse header
        header = [cell.strip() for cell in lines[0].split('|') if cell.strip()]
        
        # Skip separator line
        data_lines = lines[2:] if len(lines) > 2 else []
        
        if not header:
            return
        
        # Create table
        table = doc.add_table(rows=len(data_lines) + 1, cols=len(header))
        table.style = 'Light Grid Accent 1'
        
        # Add header
        for i, cell_text in enumerate(header):
            cell = table.rows[0].cells[i]
            cell.text = cell_text
            # Make header bold
            for paragraph in cell.paragraphs:
                for run in paragraph.runs:
                    run.font.bold = True
        
        # Add data rows
        for row_idx, line in enumerate(data_lines):
            cells = [cell.strip() for cell in line.split('|') if cell.strip()]
            for col_idx, cell_text in enumerate(cells[:len(header)]):
                table.rows[row_idx + 1].cells[col_idx].text = cell_text
        
        # Add spacing after table
        doc.add_paragraph()
    
    def _add_code_block(self, doc: Document, code: str):
        """Add code block with monospace font."""
        para = doc.add_paragraph()
        run = para.add_run(code)
        run.font.name = 'Courier New'
        run.font.size = Pt(9)
        para.paragraph_format.left_indent = Inches(0.5)
        para.paragraph_format.space_before = Pt(6)
        para.paragraph_format.space_after = Pt(6)
    
    def _add_bullet_list(self, doc: Document, text: str):
        """Add bullet list."""
        lines = text.split('\n')
        for line in lines:
            if line.strip().startswith(('-', '*', '+')):
                content = line.strip()[1:].strip()
                doc.add_paragraph(content, style='List Bullet')
    
    def _add_numbered_list(self, doc: Document, text: str):
        """Add numbered list."""
        lines = text.split('\n')
        for line in lines:
            match = re.match(r'^\d+\.\s*(.*)', line.strip())
            if match:
                content = match.group(1)
                doc.add_paragraph(content, style='List Number')